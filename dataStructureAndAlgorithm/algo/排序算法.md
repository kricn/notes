## 冒泡排序 O(N^2)
冒泡排序通过两层喧哗，将数组中的数两两比较。
```js
const arr = [1,4,2,45,23,9,22,44,10]
// 从第一个开始比较
for (let i = 0; i < arr.length; i ++) {
  // 比较第 i 个之后的元素
	for (let j = i + 1; j < arr.length; j ++) {
    // 大于则互换顺序
		if (arr[i] > arr[j]) {
			let temp = arr[j]
			arr[j] = arr[i]
			arr[i] = temp
		}
	}
}
```

## 插入排序 O(N^2)
通过下一个数和上一个数进行比较，符合条件则互换两个数的位置，不符合则退出循环
```js
function insertSort(arr) {
  if (arr.length < 2) {
    return arr
  }
  // 第一次循环，直接从第二个数开始
  for (let i = 1; i < arr.length; i ++) {
    // 第二次循环，上一个数的当前的数比较（j + 1）其实就等于 i
    for (let j = i - 1; j >= 0 && arr[j] > arr[j+1]; j --) {
      // 位运算，调换两个位置的数
      arr[j] = arr[j] ^ arr[j+1]
      arr[j+1] = arr[j] ^ arr[j+1]
      arr[j] = arr[j] ^ arr[j+1]
    }
  }
  return arr
}
```

## 选择排序 O(N^2)
选择一个元素变基点，遍历数组的其他元素，找到比基点小的元素，则更新基点并交换基点和匹配到那个元素的位置
```js
for (let i = 0; i < arr.length; i ++) {
  // 基点
	let min = arr[i] 
	for (let j = i; j < arr.length; j ++) {
		if (min > arr[j]) {
      // 符合条件，更新基点
			let temp = arr[j]
			arr[j] = min
			min = temp
		}
	}
  // 交换位置
	arr[i] = min
}
```

## 快速排序 O(NlogN)
快速排序是找到数组中的中点，以此中点为基点，将小于基点的数放在左边，大于等于的数放右边，递归左边和右边并将中点拼接起来。最差的时间复杂度是O(N^2)
```js
// 第一种，写法简单，但空间使用率不高
function quickSort(arr) {
  // 递归结束条件
	if (arr.length <= 1) {
	    return arr;
	}
  // 找到重点
	let mid = Math.floor(arr.length / 2)
  // 取中点值
	let mid_v = arr[mid]
	let left = []
	let right = []
	for (let i = 0; i < arr.length; i ++) {
    // 跳过自己，不跳过自己就会内存溢出
		if (i == mid) continue
		if (arr[i] < mid_v) {
			left.push(arr[i])
		} else {
			right.push(arr[i])
		}
	}
  // 递归并拼接数组
	return quickSort(left).concat([mid_v], quickSort(right))
}
// 第二种，荷兰国旗问题变式
// 空间复杂度都是 O(NlogN)，应为随机取一个数，涉及数学期望，时间复杂度为 O(NlogN)

function swap (arr, x, y) {
  if (x == y) return ;
  arr[x] ^= arr[y]
  arr[y] ^= arr[x]
  arr[x] ^= arr[y]
}

function quickSort(arr, L, R) {
  if (L < R) {
    // 随机取一个数和最后一个数作交换，变成概率问题
    // 与最后一个数交换后，以最后一个数作参考值，这们不用额外的空间
    swap(arr, L + Math.floor(Math.random() * (R - L + 1)), R)
    // 找到 = 区域的边界
    let p = parttition(arr, L, R)
    quickSort(arr, L, p[0] - 1)
    quickSort(arr, p[1] + 1, R)
  }
}

function parttition(arr, L, R) {
  // 小于区域
  let less = L - 1
  // 大于区域
  let more = R
  while(L<more) {
    // 符合小于区域
    if (arr[L] < arr[R]) {
      // 小于区扩大，指针右移
      swap(arr, ++less, L++)
    } else if (arr[L] > arr[R]) {
      // 大于区扩大，指针不动
      // 因为从后面交换回来的数，需要再判断一遍
      swap(arr, --more, L)
    } else {
      // 等于区，不处理，指针右移动
      L++
    }
  }
  // 交换回刚刚放在最后一个数的值
  swap(arr, more, R)
  // 返回等于区边界
  return [less + 1, more]
}
```

## 归并排序 O(NlogN)
将数组分成两份（或三，四份），分别对每一份进行排序，最后合并成一个数组
```js
function mergeSort (arr) {
  if (arr == null || arr.length < 2) {
    return ;
  }
  return process(arr, 0, arr.length - 1)
}

// 分开排序函数
function process(arr, left, right) {
  if (left == right) {
    return ;
  }
  const mid = left + ((right - left) >> 1)
  process(arr, left, mid)
  process(arr, mid + 1, right)
  merge(arr, left, mid, right)
}
// 合并函数
function merge(arr, left, mid, right) {
  let help = [];
  let i = 0;
  let p1 = left;
  let p2 = mid + 1;
  while (p1 <= mid && p2 <= right) {
    help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++]
  }
  while (p1 <= mid) {
    help[i++] = arr[p1++]
  }
  while (p2 <= right) {
    help[i++] = arr[p2++]
  }
  for (i = 0; i < help.length - 1; i ++) {
    arr[left + i] = help[i];  // 这里用 L + i 是因为起点是每个数组的第 0 个值，并不是需要排序数组的第0个
  }
}

```

## 堆排序
