## - 概念前提
1.对象（普通对象和函数对象，基本上js里都是对象）都有__proto__属性，只有函数对象独有prototype属性。
2. 对象的__proto__指向其构造函数的原型(prototype)。js里有内置有构造函数，比如Function, Object, Number, String...
3. 构造函数的prototype也是一个普通对象。
4. 每个对象都有一个constructor属性。
## - 原型链
对象访问其属性时，若本身属性不存在，则通过__proto__一层一层向其原型查找而形成的链式结构称为原型链。
![5c48cf8925d2dcead5c197e6f519de7.png](1)
## - 原型
原型指的是构造函数的prototype，其上的属性和方法能让基于此构造函数创建的对象去使用。如Array构造函数上有push方法，则通过Array构造出的的对象也可以使用。如：
```
  let arr = new Array()
  arr.push('new item')
```
arr对象没有push方法，但其构造函数的原型上有push方法，因此可以使用。
当对象所使用的属性和方法在当前对象不存在时，对像就会通过__proto__隐式原型找到其构造函数的原型，查找构造函数原型上是否有该属性或者方法，没有则一直往上找，直到终点null，形成的链式结构也叫原型链。
### - 举例
```javascript
function Person(){ ... };  //构造函数
letstudent= new Person();  //实例化Person, 创建student对旬
//Person 和 person1 都有__proto__属性，__proto__也可以叫作隐式原型
//Person作为函数，其__proto__指向Function的原型
Person.__proto__ == Function.prototype; //true
//Person.prototype是通过Object构造函数而来(4)
Person.prototype.__proto__ == Object.prototype;
//Object作为函数，其__proto__指向Function的原型
Object.__proto__ == Function.prototype; //true
//实例对象的__proto__只想其构造函数
student.__proto__ == Person.prototype;  //true
//实例person1里的constroctor属性是继承其构造函数原型上的constructor
student.constructor == Person;  //true
//构造函数原型的constructor指向其本身
Person.prototype.constructor = Person;
student.constructor == Person.prototype.constructor;  //true
Object.prototype == null;  //true
```
## - 原型的继承
### ES5继承方式
```javascript
//构造函数
function Person () {
  this.arr = [1];
  function eat(){
    console.log(`${this.name} is eatting`)
  }
}
function Student() {};
//继承自 Person
Student.prototype = new Person() //由于直接实例化Person赋给了Student, 而Person里有引用对象arr，
let stu1 = new Student()        //通过Student实例化出来的实例会共用同一个arr
let stu2 = new Student()
stu1.arr.push(2)
stu2.arr // [1,2]
```
## -end-
