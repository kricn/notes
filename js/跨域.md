## 什么是跨域

## jsonp跨域
jsonp是利用<script>标签可以跨域加载的特性，简单且兼容性好，但只能发送get请求，
封装一个jsonp函数发送请求。
```javascript
//index.html
function jsop ( {url, params, cb} ) {  //默认也只能是get，不用加type判断请求类型
  return new Promise(resolve => {
    let script = document.createElement('script')
    args = cb?{ ...args, cb }:{...args}
    let arrs = []
    for (let key in args) {
      arrs.push(`${key}=${args[key]}`)
    }
    script.src = `${url}?${arrs.join('&')}`
    document.body.appendChild(script)
    //script请求过来直接就当成script脚本会注入脚本环境
    //比如后台返回一个字符串，前端接受到后注入脚本环境就会变成变量
    //后台返回回调函数执行的表达式，那么在请求回来这后会执行回调函数
    //所以这里需要定义回调函数，并在其执行时改变promise的状态
    window[cb] = function (data) {  //这个data是后台传的，后台的数据返回在这里
      resolve(data)  //直接返回出去
      document.body.removeChild(script)  //删不删都行
    }
  })
}
jsonp({
  url: "http://localhost:3000/jsonp",
  params: {
    name: "kricn"
  },
  cb: callback    //回调名字可以前后台沟通好
}).then(res => {
  console.log(res)    //服务器返回的值
})

//server.js
const express = require("express")
const app = express() 
app.get("/jsonp", (req, res) => {
	let { cb } = req.query
	console.log(cb)
	res.send(`${cb}("hello")`)  //返回回调函数调用表达试，到了前端就会执行这个回调
})
app.listen(3000, () => {
	console.log("running...")
})
```
jsonp请求需要后端返回回调函数表达试才能该表promise的状态，不然数据请求回来了，promise状态一直pending，
数据也使用不了。若后台没有返回回调函数表达式，而是字符串，比如：obj={name:"kricn"},在一定时间的延迟后，
直接可以console.log(obj)可以打印出来
## postMessage跨域
postMessage是h5的api，可以跨域操作\
用法：otherWindow.postMessage(message, targetOrigin, [transfer])
- message是要发送的数据
- targetOrigin是要发送的目标源（地址）
```javascript
//a.html
<iframe src="b.html" id="content" onload="init()" />
<script>
function init () {
  //发送给同源下的页面
  document.getElementById("content").contentWindow.postMessage("hello", "/")
  //通过onmessage接收消息
  window.onmessage = function (e) {
    //不支持onmessage就用监听
    console.log(e.data)
  }
}
</script>

//b.html
<script>
  window.onmessage = function (e) {
    console.log(e)  //hello
    //回复源的消息
    e.source.postMessage("hi", e.source)
  }
</script>
```
postMessage虽然可以不同窗口跨域交互信息，需要有目标窗口的，基于iframe的也好，通过opener打开的也好，
otherWindow需要一个窗口对象，和window一样的对象，这个既是目标窗口\
postMessage没有收到消息的话把onmessage换成监听事件，通过window.open打开的，需要等新窗口打开后才发消息，不然新窗口收不到


